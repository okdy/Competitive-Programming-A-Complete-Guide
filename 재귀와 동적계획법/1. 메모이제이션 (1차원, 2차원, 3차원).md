대부분의 동적계획법 문제는 아래 2가지의 방법으로 풀 수 있다
1. Tabulation : 바텀-업 방식
2. Memoization : 탑-다운 방식

동적계획법 문제를 풀 수 있는 쉬운 방법중에 하나는 우선 재귀로 작동하는 코드를 작성한 뒤 재귀함수에 Bottom-up 방식의 타뷸레이션을 적용하거나, Top-down 방식의 메모이제이션을 적용하는 것이다.
어떤 문제에 대해서 탑-다운 방식인 메모이제이션을 적용하는 방법은 아래와 같다.

1. 재귀코드를 작성한다
2. 반환값을 메모하여 재귀호출을 줄이는데 사용한다

##### 1차원 메모이제이션

이때 하나의 매개변수만 상수가 아니므로 아래의 코드는 1차원 메모이제이션이라고 한다. 아래의 코드는 n번째 항의 피보나치 수열을 구하기 위한 단순한 재귀코드이다.

```cpp
int fib(int n) {
  if (n <= 1) return n;
  return fib(n-1) + fib(n-2);
}
```

$n>1$ 단계에서 2번의 호출이 필요하므로 간략하게 시간복잡도는 $O(2^N)$ 과 같다. 단순하게 생각하면 이 함수는 n이 커지면 커질수록 엄청나게 많은 함수를 호출한다. 아래의 재귀트리와 같이 4만 넣어도 8번의 호출이 발생된다.

```
		      fib(4)
		     /     \
	    fib(3)      fib(2)
	    /   \        /   \
    fib(2) fib(1) fib(1) fib(0)
    /   \
fib(1)  fib(0)
```

위의 재귀트리를 자세히 보면 2, 1, 0 과 같이 호출했던 함수가 계속 호출되는 경우가 있다. 호출된 함수에 대해서 값을 별도로 저장해놓고 다음호출때 재사용한다면 함수호출을 많이 줄일 수 있다. 이를 하향식 접근인 메모이제이션 방법을 이용하여 1차원 배열로 각 값들을 저장하면 

```cpp
int dp[100];

int fib(int n) {
  if (n <= 1) return n;
  if (dp[n] != 0) return dp[n];

  return dp[n] = fib(n-1) + fib(n-2);
}
```

우선 재귀함수에는 끝나야 하는 조건인 기저조건이 존재해야 한다. 0, 1번째 수열은 피보나치 수열에 이미 정의되어 있으므로 들어온 n의 값을 그대로 반환한다.
피보나치 수열은 항상 이전값과 이이전값을 더하므로 0보다 크다. 만약 현재 피보나치 수의 배열에 값이 0이 아니라면 값을 그대로 반환한다.
만약 0 이라면 (계산이 안된 경우) 피보나치 수의 배열에 이전값과 이이전값을 더하여 할당하고 그 값을 반환해야 한다.

위의 코드와 같이 작성하면 계산된 값은 재활용을 하므로 시간복잡도가 $O(N)$이 된다.

##### 2차원 메모이제이션
위의 1차원 메모이제이션에서는 상수가 아닌 매개변수가 1개 있었지만 2차원 메모이제이션에서는 그 매개변수가 2개일 경우에 사용된다. 단순하게 값을 저장할 수 있는 공간이 한번에 2개가 필요하므로 2차원 배열을 이용한다.

예를들어 두 개의 문자열이 주어졌을때 최장공통 문자열(Longest Common Substring)을 구하는 문제가 있다고 가정하자.