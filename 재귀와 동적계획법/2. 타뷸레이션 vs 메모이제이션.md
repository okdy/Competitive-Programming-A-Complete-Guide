동적 계획법에서 하위문제의 값을 저장하는 방식에는 2가지가 있다. 1번문서에서도 소개하지만 타뷸레이션과 메모이제이션 이 2가지가 해당된다.

##### 타뷸레이션 방식
상향식 접근방식이며 상태전환 관점에서 보면 아래와 같다.

현재 상태를 `dp[x]`로 가정하고 `dp[0]`을 기본상태로 두고 `dp[n]`을 최종목적 상태라고 가정한다. 따라서 우리가 구해야할 값은 `dp[n]`이 된다.


DP 문제를 정의하기 위해 우리가 구하려는 최종 상태는 마지막 값인 dp[n]일 것이다.


**왜 이러한 방식을 Tabulation(도표) 방법이라 하는가?**

이를 알아보기 위해 우선 팩토리얼을 상향식 접근방식을 이용하여 계산하는 코드를 작성해보겠다. 현재 상태를 `dp[x]`로 정의하며 `dp[x]`는 x의 팩토리얼을 구한 값이된다. 
많이 알려진 바와 같이 팩토리얼을 재귀적으로 나타내면 $n! = n * (n-1)!$ 와 같다.

```cpp
int dp[MAXN];

// base case 정의
int dp[0] = 1;

for (int i = 1; i <= n; i++) {
  dp[i] = dp[i-1] * i;
}
```

위의 코드는 기저사례인 `dp[0]` 부터 시작하여 목적지 상태인 `dp[n]` 까지 도달하기 때문에 상향식 접근방식을 따른다. dp배열이 순차적으로 계산되고 있으며 다음상태에서 이전상태의 값을 이용하므로 이를 Tabulation(도표) 방식이라 한다.

##### 메모이제이션 방식

다시한번 상태전환의 관점에서 살펴보겠다. 

목적지 상태인 `dp[n]`에 먼저 도달할 수 있는 상태부터 답을 구하는 것이 하향식 DP방식이다.

```cpp

// -1로 모든 값을 초기화시킨다
int dp[MAXN];

int solve(int x) {
  if (x==0) return 1;
  if (dp[x] != -1) return dp[x];

  return dp[x] = x * solve(x-1);
}
```

|               | Tabulation                                 | Memoization                        |
| ------------- | ------------------------------------------ | ---------------------------------- |
| 상태          | 상태전환 관계를 생각하기 어렵다            | 상태전환 관계를 생각하기 쉽다      |
| 코드          | 많은 조건이 있다면 코드가 복잡해진다       | 코드가 비교적 쉽다                 |
| 속도          | 이전상태의 값을 이용하여 계산하므로 빠르다 | 많은 재귀호출로 인해 비교적 느리다 |
| 하위문제 해결 |                                            |                                    |
