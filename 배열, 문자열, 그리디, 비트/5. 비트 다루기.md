경쟁 프로그래밍에서 어렵게 보이는 문제가 있지만 비트를 다룰줄 안다면 쉽게 해결할 수 있는 문제들이 많다. 

- 인덱스 0 을 기준으로 오른쪽에서 왼쪽으로 비트를 인덱싱한다
- $i$비트를 설정한다는 것은 $i$번째 비트를 1로 설정하는 것과 같다.
- $i$비트를 지운다는 것은 $i$번째 비트를 0로 설정하는 것과 같다.
- LSB(Least Significant Bit) : 가장 낮은 위치의 bit
- MSB(Most Significant Bit) : 최상위 bit

#### 1. LSB부터 $i$ 비트까지 초기화

```cpp
mask = ~((1 << i+1) - 1);
x &= mask;

// example
// x = 61 (0011 1101), LSB to 3rd bit.
// 1 << 4 = 16 (0001 0000)
// 16 - 1 = 15 (0000 1111)
// ~15 = 240 (1111 0000)
// x & 240 = 48 (0011 0000)
```
LSB부터 i 번째 비트까지 모두 지우려면 해당하는 비트에 0 으로 AND 연산을 수행해야 한다. 이러한 마스킹을 구성하려면 1을 $i+1$번째 까지 쉬프트 한 뒤 1을 빼주면 LSB부터 i 번째 비트까지 1이 구성된다. 이를 NOT연산자로 보수를 취해주면 마스킹이 완성된다.

#### 2. MSB부터 $i$ 비트까지 초기화
```cpp
mask = (1 << i) - 1;
x &= mask;

// example
// x = 61 (0011 1101), MSB to 4th bit.
// 1 << 4 = 16 (0001 0000)
// 16 - 1 = 15 (0000 1111)
// x & 15 = 13 (0000 1101)
```
MSB부터 i 번째 비트까지 모두 지우려면 (1) 의 예제와 같이 해당되는 부분을 0으로 AND 연상을 수행해 주어야 한다. MSB에서 $i$번째 비트까지 지워야 한다면 $i$ 에서 1을 빼주면 0부터 $i-1$ 까지는 1이 설정되고 나머지는 0이 되므로 마스킹이 완성된다.
**주의** 이때 MSB 부터 i 번째 비트라고 해서 왼쪽에서 오른쪽으로 인덱스를 생각하면 안된다. i 번째 비트는 무조건 오른쪽부터 시작한다는 것에 주의한다.

#### 3. 2로 나누기
```cpp
x >>= 1;
```
오른쪽 쉬프트를 수행하면 모든 비트가 오른쪽으로 이동하며 MSB는 양수의 경우 0, 음수의 경우 1의 부호비트로 대체된다.

#### 4. 2 곱하기
```cpp
x <<= 1;
```

#### 5. 대문자를 소문자로 바꾸기
```cpp
ch |= ' ';
```

#### 6. 소문자를 대문자로 바꾸기
```cpp
ch &= '_';
```

#### 7. 설정된 비트 개수세기
```cpp
int countSetBits(int x) {
  int count = 0;
  while (x) {
    x &= (x-1);
    count++;
  }
  return count;
}
```

Brian Kernighan's  알고리즘이라고도 불린다.