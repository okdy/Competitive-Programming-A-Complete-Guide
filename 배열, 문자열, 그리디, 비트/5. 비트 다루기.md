경쟁 프로그래밍에서 어렵게 보이는 문제가 있지만 비트를 다룰줄 안다면 쉽게 해결할 수 있는 문제들이 많다. 

- 인덱스 0 을 기준으로 오른쪽에서 왼쪽으로 비트를 인덱싱한다
- $i$비트를 설정한다는 것은 $i$번째 비트를 1로 설정하는 것과 같다.
- $i$비트를 지운다는 것은 $i$번째 비트를 0로 설정하는 것과 같다.
- LSB(Least Significant Bit) : 가장 낮은 위치의 bit
- MSB(Most Significant Bit) : 최상위 bit

#### 1. LSB부터 $i$ 비트까지 초기화

```cpp
mask = ~((1 << i+1) - 1);
x &= mask;

// example
// x = 61 (0011 1101), LSB to 3rd bit.
// 1 << 4 = 16 (0001 0000)
// 16 - 1 = 15 (0000 1111)
// ~15 = 240 (1111 0000)
// x & 240 = 48 (0011 0000)
```
LSB부터 i 번째 비트까지 모두 지우려면 해당하는 비트에 0 으로 AND 연산을 수행해야 한다. 이러한 마스킹을 구성하려면 1을 $i+1$번째 까지 쉬프트 한 뒤 1을 빼주면 LSB부터 i 번째 비트까지 1이 구성된다. 이를 NOT연산자로 보수를 취해주면 마스킹이 완성된다.

#### 2. MSB부터 $i$ 비트까지 초기화
```cpp
mask = (1 << i) - 1;
x &= mask;

// example
// x = 61 (0011 1101), MSB to 4th bit.
// 1 << 4 = 16 (0001 0000)
// 16 - 1 = 15 (0000 1111)
// x & 15 = 13 (0000 1101)
```
MSB부터 i 번째 비트까지 모두 지우려면 (1) 의 예제와 같이 해당되는 부분을 0으로 AND 연상을 수행해 주어야 한다. MSB에서 $i$번째 비트까지 지워야 한다면 $i$ 에서 1을 빼주면 0부터 $i-1$ 까지는 1이 설정되고 나머지는 0이 되므로 마스킹이 완성된다.
**주의** 이때 MSB 부터 i 번째 비트라고 해서 왼쪽에서 오른쪽으로 인덱스를 생각하면 안된다. i 번째 비트는 무조건 오른쪽부터 시작한다는 것에 주의한다.

#### 3. 2로 나누기
```cpp
x >>= 1;
```
오른쪽 쉬프트를 수행하면 모든 비트가 오른쪽으로 이동하며 MSB는 양수의 경우 0, 음수의 경우 1의 부호비트로 대체된다.

#### 4. 2 곱하기
```cpp
x <<= 1;
```

#### 5. 대문자를 소문자로 바꾸기
```cpp
ch |= ' ';
```

#### 6. 소문자를 대문자로 바꾸기
```cpp
ch &= '_';
```

#### 7. 설정된 비트 개수세기
```cpp
int countSetBits(int x) {
  int count = 0;
  while (x) {
    x &= (x-1);
    count++;
  }
  return count;
}
```

Brian Kernighan's  알고리즘이라고도 불린다.
간략하게 설명하면 x의 값이 존재할때까지 $(x\ge1)$ x의 값에서 1을 뺀 값과 AND연산을 처리하고 개수를 센다. AND연산에서 두가지 경우의 수가 있을 수 있다.
```cpp
45 & 44 // (0010 1101) & (0010 1100)
16 & 15 // (0001 0000) & (0000 1111)
```
위의 경우와 같이 어떤수를 -1한 값과 AND연산을 하면 마지막비트가 사라지거나 중간에 있는 비트가 사라지므로 해당되는 1의 개수만큼 사라지게 되어있다.

#### 8. 32비트 정수에서 이진로그 찾기
```cpp
int log2(int x) {
  int res = 0;
  while (x >>= 1) res++;
  return res;
}
```
매개변수 x의 값을 0이 될때까지 오른쪽 쉬프트를 해주면 밑수를 2로 하는 로그를 계산할 수 있다. 로그의 정의 그대로 0이 될때까지 밑수로 진수를 나누기 때문이다. 오른쪽 쉬프트가 2로 나누는 것은 (3)에 설명되어 있다.

#### 9. 32비트 정수가 2의 거듭제곱인지 확인
```cpp
bool isPowerof2(int x) {
  return (x && !(x & x-1));
}
```
2의 거듭제곱인 수는 1인 비트의 개수가 한개이다. 그 뜻은 2의 거듭제곱인 수에서 -1을 취하고 AND연산을 하면 그 값은 무조건 0이 나와야 한다는 이야기이다.
```cpp
32 & 31 // (0010 0000) & (0001 1111) = 0
33 & 32 // (0010 0001) & (0010 0000) = 32
```
여기서 단순하게 `!(x & x-1)` 만을 이용하여 평가할 수도 있지만 0이 들어오면 무조건 1로 평가가 되므로 반전한 값과 x를 같이 평가하여 (and연산한 값은 비트연산자로 논리값을 반전해준다) 그 결과를 반환해주면 된다.

#### 10. 마지막으로 설정된 비트 찾기
