슬라이딩 윈도우 기법은 중첩된 루프의 사용을 줄이고 단일루프로 대체하여 시간복잡도를 줄이는 것을 목표로 하는 계산기법이다.


#### 전제조건
슬라이딩 윈도우 기법은 계산해야 할 크기가 고정되어 있는 특정한 상황에서만 사용할 수 있다. 

#### 사용방법

1. 계산해야 할 윈도우 크기 정하기
2. 첫번째 윈도우먼저 계산하기
3. 루프에서 1씩 오른쪽으로 슬라이드하면서 윈도우의 결과를 계산하기

일반적으로 아래와 같은 상황에서 사용할 수 있다

- 배열
- 문자열
- 최대합
- 최소합

**예** n 크기의 정수배열이 주어졌을때, 연속된 k개의 요소의 최대합을 구하여라
만약 배열의 값이 $10, 20, 30, 40$ 이 있고 $n=4, k=2$ 일경우 $30+40=70$ 이 연속된 2개 요소의 최대합이다.

위의 문제를 무차별대입 방식으로 풀어보면, 배열의 첫번째 인덱스부터 $n-k+1$ 요소까지 $i$부터 $i+k$번째 요소까지 더해야 한다.
```cpp
int result = 0;

for (int i = 0; i < n - k + 1; i++) {
  int sum = 0;
  for (int j = i; j < i+k; j++) sum += arr[j];
  result = max(result, sum);
}
```

위의 코드는 배열의 개수 n과 윈도우의 크기 k가 중첩루프로 구성되어 있으므로 $O(N*K)$의 시간복잡도에 수행된다. 만약 k의 크기가 n에 가까워진다면 $O(N^2)$과 같다.

슬라이딩 윈도우 기법을 이해하기 위해 가장 좋은 예는 


1. 처음 k개의 요소의 합을 저장하고 window_sum 배열에 저장한다.
2. 그다음 배열의 끝에 도달할 때 까지 배열을 탐색하면서 최대합계를 갱신한다.
3. k개의 요소로 구성된 현재 윈도우의 합계를 구하려면 현재 방문한 요소의 값을 더하고 제일 마지막에 있는 값을 빼주면 된다.

$$\underbrace{5\quad2\quad-1}_{\text{sum = 6}}\quad 0\quad  3$$

$$5\quad \underbrace{2\quad-1\quad0}_{\text{sum = 6 +0 - 5 = 1}}\quad  3$$

$$5\quad 2\quad \underbrace{-1\quad0\quad3}_{\text{sum = 1 + 3 - 2 = 2}}$$