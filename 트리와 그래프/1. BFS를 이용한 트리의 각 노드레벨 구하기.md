V정점이 있는 트리가 주어졌을때 트리의 루트로 부터 각 노드의 레벨을 구하는 방법을 알아보자

```
      0
   /    \
   1     2
 / | \   |
3  4  5  6
         |
         7
```

위와 같이 구성된 트리에서 0을 기준으로 각 노드의 레벨을 구하면 아래와 같다.

```
Output :
Node Level
0    0
1    1
2    1
3    2
4    2
5    2
6    2
7    3
```

**접근방식**
BFS(Breath First Search)는 그래프 탐색방법 중 하나로 주어진 노드의 모든 이웃을 방문하고, 그 이웃의 모든 이웃을 반복방문하는 방법이다. 
간단하게 루트노드에서 레벨별로 순회하는 방식으로 루트노드의 이웃이 레벨1이 될것이고, 루트노드의 이웃의 이웃은 레벨2가 된다. 이런식으로 모든 노드를 순회하면 루트를 기준으로 각 노드의 레벨을 결정할 수 있다.

**순서**
1. 방문할 노드를 저장할 큐, 이전에 방문했는지 확인하는 배열, 노드레벨을 기록할 배열 3가지를 만들고, 시작할 노드를 큐에 넣는다
2. 큐의 크기가 0이 될때까지 반복한다
3. 큐의 맨 앞의 노드를 꺼내고 삭제한다
4. 꺼낸 노드를 방문처리한다
5. 꺼낸 노드의 모든 자식노드에 대해 레벨을 기록하고 (현재노드레벨 + 1) 큐에 삽입한다

```cpp
void printLevels(vector<int> graph[], int V, int x) {
  int level[V];
  bool marked[V];

  queue<int> q;
  q.push(x);

  level[x] = 0;
  marked[x] = true;

  while (!q.empty()) {
    x = q.front();
    q.pop();

    for (int i = 0; i < graph[x].size(); i++) {
      int b = graph[x][i];
      if (!marked[b]) {
        q.push(b);
        level[b] = level[x] + 1;
        marked[b] = true;
      }
    }
  }
}
```

BFS에서는 모든 노드를 한번씩 방문하므로 $O(V)$의 시간복잡도를 가진다. (V는 노드의 개수)