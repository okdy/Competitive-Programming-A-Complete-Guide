
### 경쟁프로그래밍은 어떻게 준비하나요?
아래는 준비해야 할 것들이다.
1.  자주 사용하는 프로그래밍 언어 (어떤 언어든 상관없지만 C/C++/JAVA를 추천)
2. 시간/공간복잡도 계산하는 방법
3. 무차별대입방법을 생각할 수 있는 능력
4. 모든 자료구조에 대한 연습 (연결리스트, 큐, 스택, 트리, 그래프 등등)

#### 1. 프로그래밍 언어 선택하기
프로그래밍 언어와 함께 관련된 문법을 배워야 한다. 여기에는 C, C++, 자바, 파이썬 등 어느 언어든 상관없다. 
#### 2. 시간복잡도와 공간복잡도에 대해 이해하기
대부분의 경우는 문제의 해답이 하나 이상인 경우가 많다. 그래서 최대한 좋은 해답을 구하기 위해 문제를 해결하기 위한 시간복잡도와 공간복잡도를 정해야할 필요가 있다.
#### 3. 자료구조와 알고리즘에 대한 기초
경쟁 프로그래밍에 있어서 자료구조와 알고리즘(원문에서는 DSA로 표현) 없이는 불가능하다. 연결리스트, 스택, 큐, 트리, 그래프, 정렬, 재귀, 동적계획법등의 기본적인 
#### 4. 연습하고 연습하기


### 11. 배열, 문자열, 탐욕, 비트의 기본

#### 2. 행렬(2차원 배열)의 누적합

integer 타입의 2차원 배열(행렬) `a[][]`이 주어졌을때 `psa[][]` 배열은 i나 j의 이전 행, 열의 모든 합을 표시한다.
$$
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 \\
\end{bmatrix}

\begin{bmatrix}
1 & 3 & 6 \\
5 & 12 & 21 \\
12 & 27 & 45 \\
\end{bmatrix}
$$
단순하게 2차원 배열의 누적합을 구하는 방식은 `a[0][0]` 부터 `a[i][j]` 까지 순회하며 더하는 방식으로 시간복잡도는 $O(R*C*R*C)$와 같다. (R은 행 개수, C는 열 개수)
이보다 효율적인 방식은 이전 행, 열에서 계산했던 값을 이용하여 계산하는 방식으로 `psa[i-1][j] + psa[i][j-1] - psa[i-1][j-1]` 으로 계산해준다.
`psa[i-1][j-1]` 을 빼 주는 이유는 합이 두번 계산되어 더해졌기 때문에 두번 계산된 부분을 제하여야 한다.
```cpp
// 최초의 경우
if (i == 0 && j ==0) {
  psa[i][j] = a[0][0];
}
// 0번째 행의 누적합
if (i == 0 && j > 0) {
  psa[i][j] = a[i][j] + psa[i][j-1];
}
// 0번째 열의 누적합
if (j == 0 && i > 0) {
  psa[i][j] = a[i][j] + psa[i-1][j];
}
```
이방식의 공간복잡도와 시간복잡도는 $O(R*C)$ 이다


#### 3. 윈도우 슬라이딩 기법

윈도우 슬라이딩 기법은 중첩루프가 필요한 상황에서 중첩루프를 줄이고 단일루프로 대체하여 시간복잡도를 줄이는 계산 기법이다. 이 기법은 중첩루프에서 계산해야 할 윈도우(배열의 열)의 크기가 고정되어 있는 경우와 같이 특이한 케이스에서 사용된다. 
**N 크기의 정수배열이 주어졌을때, 연속된 K개의 요소의 최대 값을 구하라**
$$
\begin{bmatrix}
&1&2&3&4&5&
\end{bmatrix}
$$

가장 심플한 브루트포스 방법으로 $O(N*K)$의 방법으로 0번째 부터 N-K번까지 K번 반복하여 합을 구하는 방법이 있다.
```cpp
for (int i = 0; i <= n-k; i++) {
  int sum = 0;
  for (int j = i; j < i + k; j++) {
    sum += arr[j];
  }
}
```

슬라이딩 윈도우 기법은 처음 K개의 합을 저장한 다음 1칸씩 움직일 때 마다, 다음칸의 수를 더하고 이전칸의 수를 빼는 방법이다.
$$


$$
처음 K개를 계산하고 K+1부터 N까지 선형계산하므로 시간복잡도가 $O(N)$이다. 이 기법을 이용하여 최대, 최소, 곱 등을 구할 수 있다.
